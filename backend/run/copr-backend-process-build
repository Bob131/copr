#! /usr/bin/python3

"""
Process one Build task provided by frontend (on backend).
"""

import time

from copr_common.enums import StatusEnum

from copr_backend.background_worker import BackgroundWorker
from copr_backend.job import BuildJob
from copr_backend.daemons.worker import Worker
from copr_backend.vm_alloc import ResallocHostFactory


class BuildBackgroundWorker(BackgroundWorker):
    """
    The (S)RPM build logic.
    """

    redis_logger_id = 'worker'
    job = None
    host = None

    @classmethod
    def adjust_arg_parser(cls, parser):
        parser.add_argument(
            "--build-id",
            type=int,
            required=True,
            help="build ID to process",
        )
        parser.add_argument(
            "--chroot",
            required=True,
            help="chroot name (or 'srpm')",
        )

    def mark_starting(self):
        """
        Announce to the frontend that the build is starting. Frontend may reject
        build to start.
        """
        self.job.started_on = time.time()
        self.job.status = StatusEnum("starting")
        if not self.frontend_client.starting_build(self.job.to_dict()):
            raise Exception("Frontend forbade to start the job {}".format(
                self.job.task_id))

    def get_build_job(self):
        """
        Per self.args, obtain BuildJob instance.
        """
        if self.args.chroot == "srpm-builds":
            target = "get-srpm-build-task/{}".format(self.args.build_id)
        else:
            target = "get-build-task/{}-{}".format(self.args.build_id,
                                                   self.args.chroot)
        resp = self.frontend_client.get(target)
        if resp.status_code != 200:
            self.log.error("failed to download build info, apache code %s",
                           resp.status_code)
            raise Exception("failed to get the build task {}".format(target))

        self.job = BuildJob(resp.json(), self.opts)

    def _drop_host(self):
        if not self.host:
            return
        self.host.release()
        self.host = None

    def _handle_task(self):
        self.get_build_job()
        self.mark_starting()
        tags = []
        if self.job.arch:
            tags.append("arch_{}".format(self.job.arch))
        vm_factory = ResallocHostFactory(server=self.opts.resalloc_connection)
        self.host = vm_factory.get_host(tags, self.job.sandbox)
        self.host.wait_ready()
        worker = Worker(self.opts, self.worker_id, self.host, self.job)
        worker.run()

    def handle_task(self):
        result = StatusEnum("failed")
        try:
            result = self._handle_task()
        except Exception:  # pylint: disable=broad-except
            self.log.exception("unexpected exception")
        finally:
            self._drop_host()
            self.redis_hset('status', str(result))


if __name__ == "__main__":
    BuildBackgroundWorker().process()
