#! /usr/bin/python3

"""
Process one Build task provided by frontend (on backend).
"""

import time

from copr_common.enums import StatusEnum

from copr_backend.background_worker import BackgroundWorker
from copr_backend.job import BuildJob
from copr_backend.daemons.worker import Worker
from copr_backend.vm_alloc import ResallocHostFactory
from copr_backend.cancellable_thread import CancellableThreadTask
from copr_backend.sshcmd import SSHConnection, SSHConnectionError


class BuildCanceled(Exception):
    """ asynchronous cancel request received """


class BuildBackgroundWorker(BackgroundWorker):
    """
    The (S)RPM build logic.
    """

    redis_logger_id = 'worker'
    job = None
    host = None
    ssh = None
    canceled = False

    @classmethod
    def adjust_arg_parser(cls, parser):
        parser.add_argument(
            "--build-id",
            type=int,
            required=True,
            help="build ID to process",
        )
        parser.add_argument(
            "--chroot",
            required=True,
            help="chroot name (or 'srpm')",
        )

    def mark_starting(self):
        """
        Announce to the frontend that the build is starting. Frontend may reject
        build to start.
        """
        self.job.started_on = time.time()
        self.job.status = StatusEnum("starting")
        if not self.frontend_client.starting_build(self.job.to_dict()):
            raise Exception("Frontend forbade to start the job {}".format(
                self.job.task_id))

    def get_build_job(self):
        """
        Per self.args, obtain BuildJob instance.
        """
        if self.args.chroot == "srpm-builds":
            target = "get-srpm-build-task/{}".format(self.args.build_id)
        else:
            target = "get-build-task/{}-{}".format(self.args.build_id,
                                                   self.args.chroot)
        resp = self.frontend_client.get(target)
        if resp.status_code != 200:
            self.log.error("failed to download build info, apache code %s",
                           resp.status_code)
            raise Exception("failed to get the build task {}".format(target))

        self.job = BuildJob(resp.json(), self.opts)

    def _drop_host(self):
        if not self.host:
            return
        self.host.release()
        self.host = None

    def _title(self, text):
        text = "Builder for task {}: {}".format(self.job.task_id, text)
        self.log.debug("setting title: %s", text)
        self.setproctitle(text)

    def _cancel_task_check_request(self):
        self.canceled = bool(self.redis_get_worker_flag("cancel_request"))
        return self.canceled

    def _alloc_host(self):
        """
        Set self.host with ready RemoteHost, and return True.  Keep re-trying
        upon allocation failure.  Return False if the request was canceled.
        """
        tags = []
        if self.job.arch:
            tags.append("arch_{}".format(self.job.arch))

        vm_factory = ResallocHostFactory(server=self.opts.resalloc_connection)
        while True:
            self.host = vm_factory.get_host(tags, self.job.sandbox)
            self._title("Waiting for VM, info: {}".format(self.host.info))
            success = CancellableThreadTask(
                self.host.wait_ready,
                self._cancel_task_check_request,
                self._drop_host,
            ).run()
            if self.canceled:
                raise BuildCanceled
            if success:
                return True

    def _alloc_ssh_connections(self):
        self.ssh = SSHConnection(
            user=self.opts.build_user,
            host=self.host.hostname,
            config_file=self.opts.ssh.builder_config
        )

    def _cancel_running_worker(self):
        self._title("Canceling running task...")
        try:
            cmd = "cat /var/lib/copr-rpmbuild/pid"
            rc, out, err = self.ssh.run_expensive(cmd)
            if rc:
                if "No such file" in err:
                    self.log.warning("no PID file to cancel")
                    return
                msg = "Can't get PID file to cancel {}".format(err)
                raise Exception(msg)
            pid = int(out.strip())
            # TODO: kill -9 can keep mock around
            self.log.info("killing PID %s on worker", pid)
            self.ssh.run_expensive("kill -9 -{}".format(pid))
        except ValueError:
            raise Exception("Can't parse PID to cancel")
        except SSHConnectionError:
            raise Exception("Can't ssh to cancel build.")

    def _handle_task(self):
        self.get_build_job()
        self.mark_starting()
        self._alloc_host()
        self._alloc_ssh_connections()
        self._title("Job {}, host info: {}".format(self.job.task_id,
                                                   self.host.info))
        worker = Worker(self.opts, self.worker_id, self.host, self.job)
        CancellableThreadTask(
            worker.run,
            self._cancel_task_check_request,
            self._cancel_running_worker,
        ).run()
        if self.canceled:
            raise BuildCanceled

    def handle_task(self):
        result = StatusEnum("failed")

        try:
            result = self._handle_task()
        except BuildCanceled:
            self.log.error("build was canceled")
            self.redis_set_worker_flag("fail_reason", "Build was canceled.")
        except Exception:  # pylint: disable=broad-except
            self.log.exception("unexpected exception")
            self.redis_set_worker_flag("fail_reason", "Unexpected exception.")
        finally:
            self._drop_host()
            self.redis_set_worker_flag('status', str(result))


if __name__ == "__main__":
    BuildBackgroundWorker().process()
